<!DOCTYPE html>
<html>

    <head>
        <title>Actor-Critic Methods</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <!-- theme -->
        <link rel="stylesheet" href="/assets/css/prism.css"/>
        <!-- UIKit -->
        <link rel="stylesheet" href="/assets/css/uikit.min.css"/>
        <script src="/assets/js/uikit.min.js"></script>
        <script src="/assets/js/uikit-icons.min.js"></script>
        <!-- Prism -->
        <link rel="stylesheet" href="/assets/css/theme.css"/>
        <script src="/assets/js/prism.js"></script>
        <!-- GoogleFonts -->
        <link href="https://fonts.googleapis.com/css?family=Lora" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Fjalla+One" rel="stylesheet">
        <!-- KaTeX -->
        <script src="//code.jquery.com/jquery-1.11.1.min.js"></script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"></script>
    </head>

    <body class="uk-background uk-height-viewport">

        <div class="tm-navbar-container" uk-sticky="animation: uk-animation-slide-top; sel-target: .uk-navbar-container; cls-active: uk-navbar-sticky; cls-inactive: uk-navbar-transparent; top: 300">

    <nav class="uk-navbar-container" uk-navbar style="position: relative; z-index: 980;">

        <div class="uk-navbar-center">

            <div class="uk-navbar-center-left">
                <div>
                    <ul class="uk-navbar-nav">
                        
                            <li class="uk-active"><a class="tm-navbar-item" href="/index.html">Blog</a></li>
                        

                        
                            <li><a class="tm-navbar-item" href="/info.html">Info</a></li>
                        
                    </ul>
                </div>
            </div>

            <a class="uk-navbar-item uk-logo" href="#">
                <img uk-svg src="/assets/img/penguin.svg" style="width:56px; height: 56px;">
            </a>

            <div class="uk-navbar-center-right">
                <div>
                    <ul class="uk-navbar-nav">
                        <li>
                            <a href="https://github.com/cswaney" uk-icon="icon: github; ratio: 1.5"></a>
                        </li>
                        <li>
                            <a href="https://twitter.com/SwaneyColin?lang=en" uk-icon="icon: twitter; ratio: 1.5"></a>
                        </li>
                    </ul>
                </div>
            </div>

        </div>

    </nav>

</div>


        <div class="uk-section uk-section-default uk-section-small uk-padding-remove-top uk-margin-small-top">
        <!-- <div class="uk-section uk-section-default uk-section-small uk-margin-large-top"> -->

                <div class="uk-container uk-container-small uk-position-relative">

    <div>
        <article class="uk-article">

            <!-- <h1 class="uk-article-title"><a class="uk-link-reset" href="">Actor-Critic Methods</a></h1> -->
            <h1 class="uk-article-title uk-margin-medium-top">Actor-Critic Methods</h1>

            <!-- <p class="uk-article-meta tm-article-meta">Written by <a href="#">Colin Swaney</a> on Wednesday, July 3, 2019</a></p> -->
            <p class="uk-article-meta tm-article-meta">Wednesday, July 3, 2019</p>

            <!-- tags... -->

            <p>There are two standard algorithms in reinforcement learning: Q-learning and the policy gradient method. These methods represent orthogonal approaches. Policy gradient methods work on the policy function; Q-learning works on the action-value function. Policy gradient methods use Monte Carlo approximation; Q-learning uses bootstrap updates. And finally, policy gradient methods are low bias, high variance, while Q-learning is a low variance, high bias approach. In statistical learning, there is always some balance of bias and variance that provides the best outcome. Actor-critic methods provide, in some sense, a compromise between Q-learning and policy gradient methods, and can be thought of as a way to balance out the costs and benefits of these approaches.</p>

<h2 id="algorithm">Algorithm</h2>
<p>Recall that the vanilla policy gradient algorithm attempts to directly improve a random policy <script type="math/tex">\pi</script> by moving in the direction of highest expected return,</p>

<script type="math/tex; mode=display">\theta \leftarrow \theta + \alpha \nabla_{\theta}J(\theta),</script>

<p>where <script type="math/tex">J(\theta)</script> is the expected return under policy <script type="math/tex">\pi_{\theta}</script>. The gradient term depends on the policy network probabilities, <script type="math/tex">\pi_{\theta}(a_t \vert s_t)</script>, and the rewards generated in each episode, <script type="math/tex">R_t</script>:</p>

<script type="math/tex; mode=display">J(\theta) \approx \sum_{t=1}^T \log \pi_{\theta}(a_t \vert s_t) R_t.</script>

<p>The expression above is a very <em>noisy</em> estimate of the expected return (because episode returns have a lot of variance), which flows into policy gradient updates. You will therefore hear people say that vanilla policy gradient is a “high variance” method. The standard approach to reduce the variance of the updates is to  subtract a “baseline” from <script type="math/tex">R_t</script>. A baseline that is itself an estimate of the expected reward can result in a much smaller weights, <script type="math/tex">\|R_t - b_t \|   \ll \|R_t\|</script>. In other words, subtracting a baseline results in a <em>re-scaling</em> of the updates.</p>

<p>Actor-critic methods replace both <script type="math/tex">R_t</script> and <script type="math/tex">b_t</script> with approximations based on the value function. First, we want <script type="math/tex">b_t</script> to be an approximation of the value function, so we replace it by the output of a network  <script type="math/tex">\hat{V}^{\pi}_{\phi}(s_t) \approx V^{\pi}(s_t)</script>. Second, according to the Bellman equation, the expected reward-to-go is equal to</p>

<script type="math/tex; mode=display">E[R_t] = E \left[r(s_t, a_t) + V^{\pi}(s_t') \right].</script>

<p>If we knew the value function, then we could estimate this quantity by evaluating it at random sample transitions <script type="math/tex">\{s_t, a_t, r_t, s_t'\}</script>. Instead, we add a second approximation error by replacing the true value function with the sample network that we used above. So our estimate of the second term becomes</p>

<script type="math/tex; mode=display">E[R_t] \approx r(s_t, a_t) + \hat{V}_{\phi}^{\pi}(s_t')</script>

<p>The overall result is that we’ve replaced <script type="math/tex">R_t - b_t</script> with <script type="math/tex">r(s_t, a_t) + \hat{V}_{\phi}^{\pi}(s_t') - \hat{V}_{\phi}^{\pi}(s_t)</script>. The latter expression can be seen as an approximation of the <em>advantage</em> function, <script type="math/tex">A^{\pi}(s_t, a_t) = Q^{\pi}(s_t, a_t) - V^{\pi}(s_t),</script> and the resulting algorithm (as described here) is commonly referred to as the “advantage actor-critic” or “A2C” algorithm. We call this a “bootstrap” estimator because it estimates <script type="math/tex">V</script> based in part on previous estimate. For comparison, we could also approximate <script type="math/tex">E[R_t]</script> using observed rewards,</p>

<script type="math/tex; mode=display">\sum_{\tau = t}^{T} r(s_{\tau}, a_{\tau}),</script>

<p>which gives an alternative, Monte-Carlo version of the A2C algorithm.</p>

<p>The A2C algorithm performs two “sub-updates” per full update: one to update the value function, and one to update the policy. The first update is similar to the update performed in the DQN algorithm. There is a slight difference however. For one thing, we’re updated the value function instead of the action-value function. More importantly, the network used to find targets is the same network used to make predictions. In the DQN algorithm, we use a “cloned” network to find targets. The second update looks like a policy gradient update, and it is, except that we’ve approximated the reward and baseline. Therefore it seems reasonable to think of this algorithm as a combination of the two classics. That being said, why don’t we also use a “clone” network to perform the value update in the A2C algorithm? (I don’t know the answer, so this is really a question I’d like to know the answer to!)</p>

<blockquote>
  <h4 id="algorithm-batch-a2c">Algorithm (Batch A2C)</h4>
  <ol>
    <li>Sample experiences <script type="math/tex">\{s_i, a_i, r_i, s'_i\}_{i=1}^N</script> using policy <script type="math/tex">\pi_{\theta}(a_i \vert s_i)</script></li>
    <li>Calculate value targets <script type="math/tex">\{y_i\}_{i=1}^N</script> defined as <script type="math/tex">y_i = r_i + \gamma V_{\phi}^{\pi}(s_i')</script></li>
    <li>Update <script type="math/tex">V_{\phi}^{\pi}</script> by minimizing <script type="math/tex">\|y_i - V_{\phi}^{\pi}(s_i)\|^2_2</script></li>
    <li>Calculate policy targets <script type="math/tex">\{A_i\}_{i=1}^N</script> defined as <script type="math/tex">A_i = y_i - V_{\phi}^{\pi}(s_i   )</script></li>
    <li>Update <script type="math/tex">\pi_{\theta}(a_i \vert s_i)</script> by maximizing <script type="math/tex">\sum_{i=1}^N \log \pi_{\theta}(a_i \vert s_i) A_i</script></li>
  </ol>
</blockquote>

<p><strong>Notes</strong> 1. In step (3) the targets <script type="math/tex">y_i</script> are treated as constants (even though they depend on the value network). 2. In step (4) we are using the updated value network to re-calculate <script type="math/tex">y_i</script> and <script type="math/tex">V_{\phi}^{\pi}(s_i)</script>. 3. In step (5) the targets <script type="math/tex">A_i</script> are treated as constants (or else <script type="math/tex">\phi</script> will also update–we only want to update <script type="math/tex">\theta</script> in this step).</p>

<h3 id="aside-variance-and-bias">Aside: Variance and Bias</h3>
<p>I’d like to point out a few facts that help to compare the actor-critic method outlined above with the policy gradient method it mirrors. First, I want to say that the policy gradient algorithm is <em>unbiased</em>, while the actor-critic method is (in general) <em>biased</em>. What I mean by this statement is this: both algorithms work by approximating the expected return of policy <script type="math/tex">\pi</script>, and using that approximation to decide how to improve the policy. The value that we use to approximate the value we really want is called “unbiased” if it equals the true value on average; otherwise, its biased. The practical way to think about this is that unbiased methods will eventually bring you arbitrarily close to the truth if you collect enough data: if I played enough games, I would eventually get a very good idea of the expected return of <script type="math/tex">\pi</script>. A biased method method will <em>always</em> leave some room for improve–even at infinity.</p>

<p>Now for the second claim: the policy gradient approach has a higher variance than the actor-critic method. What do I mean by that? Essentially that the value I am using to approximate the true value I’m interested is expected to vary more under the policy gradient approach than under the actor-critic approach. The reason is that the policy gradient approach uses the full reward-to-go, which potentially varies <em>a lot</em>, depending on the environment, whereas the actor-critic method uses a value that is typically close to zero (because they are regression residuals). The rest of the approximation is identical.</p>

<p>Why does all this matter? <em>All</em> statistical learning–to the extent that it attempts to learn the value of some function–is subject to a “bias-variance tradeoff”, whereby methods which lower bias tend to have higher variance, and vice-a-versa. What method works best in any particular application depends on what data is available, and, generally speaking, when there isn’t that much data available, low variance methods work better. In reinforcement learning, we’re really in a low-data environment when we consider the complexity of the system the agent is trying to learn and the limited number of times that it can interact with that environment. As an analogy, if our task was instead to estimate a regression model in a standard supervised learning task, if we are given only a small amount of data, then it may well be that a simple linear model outperforms nonlinear alternatives because those methods overfit small samples. The same thing is principle is at work here: we are accepting bias in our estimate in exchange of reduced variance, and the result tends to perform better, empirically (on interesting problems).</p>

<h2 id="implementation">Implementation</h2>
<ul>
  <li>In this implementation I’ll use two networks, one to represent the actor (<script type="math/tex">\pi</script>), and one to represent the critic (<script type="math/tex">V</script>). It’s also possible to train a single network with two branches. This might make sense if the network contains convolutional layers so as to provide each branch with the same visual information.</li>
  <li>The actor-critic algorithm is similar to the basic policy gradient algorithm, so we can mostly use the same routines from before. The main “gotcha” is making sure that training operations modify the correct parameters based on the correct errors. In step (2), we calculate targets <script type="math/tex">y_i</script> using the value network <script type="math/tex">V_{\phi}^{\pi}</script>. In the following step we want to update the parameters <script type="math/tex">\phi</script> based on <script type="math/tex">V_{\phi}^{\pi}(s_i')</script>, treating the <script type="math/tex">y_i</script> as fixed. The simple way to do this is to calculate the targets and the update in separate steps:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">targets</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span><span class="n">states_pl</span><span class="p">:</span> <span class="n">states</span><span class="p">})</span>
<span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">values_update</span><span class="p">,</span> <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span><span class="n">states_pl</span><span class="p">:</span> <span class="n">next_states</span><span class="p">,</span> <span class="n">targets_pl</span><span class="p">:</span> <span class="n">targets</span><span class="p">})</span>
</code></pre></div>    </div>
  </li>
  <li>Now once again in the policy update, <script type="math/tex">A_i</script> involves the value network, so an update that directly used the <script type="math/tex">A_i</script> <em>tensor</em> would update <script type="math/tex">\theta</script> and <script type="math/tex">\phi</script>. We can do the same thing as before, pre-calculating the weights <script type="math/tex">A_i</script>, and then feeding these as constants in the policy update operation. First, we get new <script type="math/tex">y_i</script> targets based on the updated value network
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">targets</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span><span class="n">states_pl</span><span class="p">:</span> <span class="n">states</span><span class="p">}),</span>
</code></pre></div>    </div>
    <p>then we calculate the weights and update the policy network</p>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">weights</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span><span class="n">states_pl</span><span class="p">:</span> <span class="n">next_states</span><span class="p">})</span>
<span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">policy_update</span><span class="p">,</span> <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span><span class="n">states_pl</span><span class="p">:</span> <span class="n">states</span><span class="p">,</span> <span class="n">actions_pl</span><span class="p">:</span> <span class="n">actions</span><span class="p">,</span> <span class="n">weights_pl</span><span class="p">:</span> <span class="n">weights</span><span class="p">})</span>
</code></pre></div>    </div>
  </li>
  <li>The rest of the implementation basically follows the policy gradient implementation.</li>
</ul>

<h2 id="extensions">Extensions</h2>

<h3 id="step-size">Step Size</h3>
<p>I mentioned an alternative Monte Carlo based approach earlier that simply uses the observed reward-to-go values, and I also mentioned that the actor-critic method is in some sense a combination of Q-learning and policy gradient with baseline. Now the question is, can I somehow vary the degree of the combination? Instead of approximating the reward-to-go by <script type="math/tex">r(s_t, a_t) + \gamma V_{\phi}^{\theta}(s_{t + 1})</script>, I could expand the approximation one step and use</p>

<script type="math/tex; mode=display">r(s_t, a_t) + \gamma r(s_{t + 1}, a_{t + 1}) + \gamma^2 V_{\phi}^{\pi}(s_{t + 2})</script>

<p>If I kept replacing <script type="math/tex">V</script> terms like this until I reached the end of the episode, then I’d end up with the full reward-to-go! In other words, as I increase the expansion my update gradually turns into the Monte Carlo algorithm. In terms of our implementation, the only difference is that we need to keep track of <script type="math/tex">N</script>-step transitions, and feed these to the graph–the graph itself is exactly the same. Small values of <script type="math/tex">N</script> (e.g., <script type="math/tex">N = 3, 4</script>) can help stabilize the A2C learning curve in the CartPole environment the same way they help stabilize DQN.</p>

<h3 id="memory-replay">Memory Replay</h3>
<p>DQN uses another trick to stabilize the training process, which is to keep a memory of transitions instead of just using the most recent <code class="language-plaintext highlighter-rouge">batch_size</code> transitions to update the value function. Can we use the same trick to stabilize A2C?</p>

<h3 id="entropy">Entropy</h3>
<p><a href="">Mnih et al. (2016)</a> include the entropy of the policy as an additional term in their policy update. The idea is to <em>encourage</em> policies to be more random than they would be otherwise, which can be seen as a way to encourage exploration (entropy is maximized by a uniform random variable–that is, a policy that picks actions at random with equal probability). The update now maximizes the quantity</p>

<script type="math/tex; mode=display">\sum_{i=1}^N \log \pi_{\theta}(a_i \vert s_i) A_i + \beta H(\pi_{\theta}(s_t)),</script>

<p>where <script type="math/tex">H(\pi_{\theta}(s_t))</script> is the entropy of the policy,</p>

<script type="math/tex; mode=display">H(\pi_{\theta}(s_t)) = - \sum_{k=1}^K \pi_{\theta}(a_t = k \vert s_t) \log \pi_{\theta}(a_t = k \vert s_t)</script>

<p>In Tensorflow, we adjust our policy update as follows:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">entropy_loss</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span>
    <span class="n">tf</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">policy_logits</span><span class="p">),</span>  <span class="c1"># probabilities
</span>        <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">policy_logits</span><span class="p">)</span>  <span class="c1"># log probabilities
</span>    <span class="p">)</span>
<span class="p">)</span>
<span class="n">policy_update</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">AdamOptimizer</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">lr</span><span class="p">)</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">policy_loss</span> <span class="o">+</span> <span class="n">entropy_loss</span><span class="p">)</span>
</code></pre></div></div>

<p>Note that there is no negative sign in front of the entropy calculation because we want to <em>maximize</em> entropy, and therefore we need to minimize <em>negative</em> entropy.</p>


        </article>

    </div>

    <div style="position: absolute; width: 200px; top: 0px; left: 860px;">
        <div uk-sticky="offset: 260">
            <ul class="uk-nav uk-nav-default uk-nav-parent-icon tm-nav" uk-scrollspy-nav="closest: li; scroll: true; offset: 100">
                
                    <li><a href="#algorithm" uk-scroll>Algorithm</a></li>
                
                    <li><a href="#implementation" uk-scroll>Implementation</a></li>
                
                    <li><a href="#extensions" uk-scroll>Extensions</a></li>
                
            </ul>
        </div>
    </div>

    <div id="disqus_thread" class="uk-margin-large-top"></div>
    <script>
        /**
        *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
        *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
        /*
        var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };
        */
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://katabaticwindblog.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</div>


        </div>

        <div class="uk-section uk-section-xsmall tm-footer">
    <div class="uk-container uk-container-small uk-position-relative">
        <ul class="uk-navbar-nav uk-align-center">
            <li>
                <a href="#">cswaney.github.io</a>
            </li>
            <!-- <li>
                <p class="uk-text-center uk-text-small">Created with <a href="https://getuikit.com" uk-icon="icon: uikit; ratio: 1.0"></a></p>
            </li> -->
        </ul>
    </div>
</div>


        <!-- convert MathJax to KaTex -->
        <script>
          $("script[type='math/tex']").replaceWith(function() {
              var tex = $(this).text();
              return katex.renderToString(tex.replace(/%.*/g, ''), {displayMode: false});
          });

          $("script[type='math/tex; mode=display']").replaceWith(function() {
              var tex = $(this).html();
              return katex.renderToString(tex.replace(/%.*/g, ''), {displayMode: true});
          });
        </script>

    </body>

</html>
